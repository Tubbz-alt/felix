\documentclass[oneside]{book}
\usepackage{float}
\usepackage{xcolor}
\definecolor{cxxbg}{rgb}{0.95,0.85,0.95}
\definecolor{felixbg}{rgb}{0.95,0.95,0.95}
\definecolor{felixlibbg}{rgb}{0.95,0.95,0.85}
\definecolor{emphcolor}{rgb}{0.5,0.0,0.0}
\newcommand{\empha}{\bf\color{emphcolor}}
\usepackage{parskip}
\usepackage{framed}
\usepackage[newfloat=true]{minted}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amscd}
\usepackage{imakeidx}
\usepackage[chapter]{tocbibind}
\usepackage{tikz}
\usetikzlibrary{shapes,shadows,arrows}
\makeindex[title=General Index]
\makeindex[name=codeindex,title=Code Index]
\usemintedstyle{friendly}
\setminted{bgcolor=felixlibbg,xleftmargin=20pt}
\usepackage{hyperref}
\hypersetup{pdftex,colorlinks=true,allcolors=blue}
\newcommand*{\fullref}[1]{\hyperref[{#1}]{\autoref*{#1} \nameref*{#1}}}
\usepackage{hypcap}
\usepackage{caption}
\DeclareMathOperator{\quot}{div}
\DeclareMathOperator{\rmd}{rmd}
\title{Felix Architecture}
\author{John Skaller}
\begin{document}
\maketitle
\tableofcontents
\chapter{Introduction}
This document describes the architecture of the Felix system.
The Felix compiler generates C++ which implements the architecture
in conjunction with the Felix run time system, which is implemented in C++.

\chapter{Library Model}
The Felix compiler generates libraries not programs.
The default library is a system shared library which acts as a plugin
to a stub loader which loads the library dynamically. Special thunks
are generated to also allow static linkage.

In the user program text, top level variables are aggregated in a C++ struct
of type \verb$thread_frame_t$ called a {\em thread frame}. The top level executable
code is gathered into a function called \verb$modulename::_init_$ which is the 
constructor code for the user part of the thread frame. The modulename is typically the base
file name.

The thread frame also contains a pointer to the garbage collector profile
object, the command line arguments, and pointers to three C \verb$FILE$ representing standard input,
output, and error, respectively.

The main constructor routine \verb$modulename_start$ is an extern "C" 
function which accepts the garbage collector profile object, command line arguments,
and standard files, stores them in the thread frame, and then calls the user initialistion
routine to complete the setup of the thread frame.

The execution of the initialisation code may have observable behaviour.
In this case the user often thinks of this as the running of the program.

Although the thread frame may be considered as global data, there are two
things to observe. The thread frame, together with the library code,
is called an {\em instance} of the library. More than one instance
of the same library may be created.

In addition, code can load additional libraries at run time. If these are
standard Felix libraries, they too have their own initialisation function
and a constructor which creates an initial thread frame.

All thread frames contain some standard data, in particular, a pointer
to the system garbage collector. Thread frames are shared by threads.
\section{Entry Points}
The standard entry points for a Felix library are:

\begin{enumerate}
\item \verb$modulename_thread_frame_creator: thread_frame_creator_t$
\item \verb$modulename_flx_start: start_t$
\item \verb$modulename_flx_main: main_t$
\end{enumerate}

Where:

\begin{minted}{c++}
typedef void *
(thread_frame_creator_t)
(
  gc_profile_t*,      // garbage collector profile
  void*               // flx_world pointer
);

typedef ::flx::rtl::con_t *
(start_t)
(
  void*,              //thread frame pointer 
  int, char **,       // command line arguments
  FILE*, FILE*, FILE* // standard files 
);

typedef ::flx::rtl::con_t *
(main_t)
(
  void*               // thread frame pointer
);
\end{minted}

\subsection{Example Hello World}
For example, given Felix program, found in top level of repository as \verb$hello.flx$:
\begin{minted}{felix}
println$ "Hello World!";
\end{minted}

we get, on MacOS:

\begin{minted}{text}
~/felix>flx -od . hello
Hello World!
~/felix>llvm-nm --defined-only -g hello.dylib
00000000000018c0 T _hello_create_thread_frame
0000000000001910 T _hello_flx_start
\end{minted}

\subsection{Thread frame creator}
The thread frame creator accepts a garbage collector profile
pointer and a pointer to the Felix world object, allocates
a thread frame and returns a pointer to it.

\subsubsection{Start routine}
The start routine accepts the thread frame pointer,
command line arguments, and standard files, stores
this data in the thread frame, constructs a suspension
of the user initialisation routine, and returns it.

The client must run the suspension to complete the initialisation.
If Felix is able to run the routine as a C procedure, the suspension
may be NULL.

\subsubsection{Generated C++}
The actual C++ generated with some stuff elided for clarity is shown below.
The header is shown in \ref{Hello header} and the body in \ref{Hello body}.
The macros used are from the Felix run time library, and are
shown in \ref{frame wrapper macro}
and \ref{start function macro}.


\begin{figure}[p]
\caption{Hello header\label{Hello header}}
\begin{minted}{c++}
namespace flxusr { namespace hello {

//PURE C PROCEDURE <64762>: _init_ unit -> void
void _init_();

struct thread_frame_t {
  int argc;
  char **argv;
  FILE *flx_stdin;
  FILE *flx_stdout;
  FILE *flx_stderr;
  ::flx::gc::generic::gc_profile_t *gcp;
  ::flx::run::flx_world *world;
  thread_frame_t(
  );

};
}} // namespace flxusr::hello
\end{minted}
\end{figure}

\begin{figure}[p]
\caption{Hello body\label{Hello body}}
\begin{minted}{c++}
namespace flxusr { namespace hello {

//Thread Frame Constructor
thread_frame_t::thread_frame_t() : gcp(0) {}

//------------------------------
//C PROC <64762>: _init_
void _init_(){
  {
    _a17556t_66120 _tmp66124 = 
      ::std::string("Hello World!") + ::std::string("\n") ;
    ::flx::rtl::ioutil::write(stdout,((_tmp66124)));
  }
  fflush(stdout);
}

}} // namespace flxusr::hello

//CREATE STANDARD EXTERNAL INTERFACE
FLX_FRAME_WRAPPERS(::flxusr::hello,hello)
FLX_C_START_WRAPPER_NOPTF(::flxusr::hello,hello,_init_)

\end{minted}
\end{figure}
\begin{figure}[p]
\caption{Frame wrapper macro\label{frame wrapper macro}}
\begin{minted}{c++}
#define FLX_FRAME_WRAPPERS(mname,name) \
extern "C" FLX_EXPORT mname::thread_frame_t *\
  name##_create_thread_frame(\
    ::flx::gc::generic::gc_profile_t *gcp,\
    ::flx::run::flx_world *world\
  )\
{\
  mname::thread_frame_t *p = \
    new(*gcp,mname::thread_frame_t_ptr_map,false)\
      mname::thread_frame_t();\
  p->world = world;\
  p->gcp = gcp;\
  return p;\
}
\end{minted}
\end{figure}

\begin{figure}[p]
\caption{Start function macro\label{start function macro}}
\begin{minted}{c++}
// init is a C procedure, NOT passed PTF
#define FLX_C_START_WRAPPER_NOPTF(mname,name,x)\
extern "C" FLX_EXPORT ::flx::rtl::con_t *name##_flx_start(\
  mname::thread_frame_t *__ptf,\
  int argc,\
  char **argv,\
  FILE *stdin_,\
  FILE *stdout_,\
  FILE *stderr_\
) {\
  mname::x();\
  return 0;\
}
\end{minted}
\end{figure}

The thread frame is accepted by the
external routine but is not passed to the init procedure because it
has been optimised to a C procedure which doesn't use the thread frame.


\subsection{main procedure}

The \verb$modulename_flx_main$ entry point is the analogue of C/C++ \verb$main$.
It accepts the pointer to the thread frame as an argument.
It is optional. If the symbol is not found, a \verb$NULL$ is returned.

\subsection{Execution}
Loading and execution of dynamic primary Felix libraries is typically
handled by one of two standard executables:

\begin{enumerate}
\item \verb$flx_arun$ is the standard loader, it loads the asynchronous I/O subsystem on demand
\item \verb$flx_run$ is a restricted loader that cannot load the asynchronous I/O subsystem
\end{enumerate}


\subsection{Other entry points}
A Felix library may contain arbitrary user defined entry points.
These are created by the \verb$export$ operator.

\subsection{C libraries}
Felix compiler can also generate plain C/C++ libraries.
Such a library contains only the explicitly exported symbols,
does not have the thread frame creator, initialiser, or main
symbols, and cannot use any Felix facilities since it has
no access to the garbage collector or \verb$flx_world$ control.

\subsection{CPython libraries}
Felix can generate of CPython 3.x extensions.  If any 
function is exported as \verb$python$ a module table is
created automatically and all the python exports included
in that table. The standard entry point \verb$PyInit_modulename$

CPython extensions coexist with all other library forms.

\subsection{Plugins}
A Felix plugin is a special Felix library object.
It contains the usual thread frame creator an initialisation
routine and two additional routines. The first is an extra
setup routine, which accepts a thread frame pointer and a 
C++ string argument and returns an int.

\begin{enumerate}
\item \verb$modulename_setup$
\end{enumerate}

of C++ type:

\begin{minted}{C++}
int setup_t
(
  void * // thread frame pointer
  std::basic_string<char>
);
\end{minted}

and Felix type:

\begin{minted}{C++}
  string -> int
\end{minted}

It is called by the plugin loader after the standard initialisation,
and is used to customise the library instance.

Plugins also contain at least one additional function, which is typically a factory
function that returns Felix object containing the actual plugin API
as a record. The Felix library contains some polymorphic routines
for loading plugins.

\section{Static linkage}
All Felix libraries can be statically linked. If static linkage is selected,
the compiler will generate an object file called a static link thunk.

The standard Felix loaders, \verb$flx_run$ and \verb$\flx_arun$ find shared
libraries and entry points by using the string name of the library.
Static link versions of these files must use fixed names instead.
To make this work, they link to a static link thunk which in turn
links to the actual symbols.

\section{Dynamic loader hook}
Felix commands to load libraries in general, and plugins in
particular, do not actually load libraries or link to symbols
directly. Instead, the commands are hooked to first look in
a database of loaded libraries and symbols. If the library and
its symbols are found in the database, the relevant addresses
are used instead of loading the library, or searching for the
symbols required in it.

Otherwise, the library is loaded dynamically and the symbols
required searched for. The resulting symbol addresses are
then stored in the database.

The purpose of this mechanism is to allow static linkage of
the library or plugin, avoiding a run time search.
Note that even statically linked primaries can still dynamically
link plugins. If a program requires known plugins, pre-linking
them makes the program more reliable and easier to ship.

Felix has special syntax for populating the run time symbol
database. Once populated, attempts to load the library and symbols
will transparently use the pre-linked version instead.

\chapter{Routines}
Felix has several different kinds of routines.

\section{Displays}
A display is simply a list of pointers to the last activation record of 
the calling parent, grand parent, and all ancestors, up to and including
the top level thread frame object.

An activation record containing a display is called a closure.
Note that closures capture activation record addresses not the
values in them, so that if an activation record contains a mutable
variable which is changed, the closure will see the changed value too.


\section{Functions}
Felix supports three function types:

\begin{minted}{felix}
  D -> C      // standard function
  D ->. C     // linear function
  D --> C     // C function
\end{minted}

The standard and linear functions are represented by an object containing a display,
and containing a non-static member named \verb$apply$ which accepts as an argument
a value of the function domain type, and returns a value of the function codomain type.

The caller address for a function is stored on the machine stack.

The standard model for a function can be replaced by a more efficient representation.
Felix can use an ordinary C function sometimes, or even eliminate the function
by inlining. The display can also be reduced to contain only pointers that are
required. In particular special binders can force the elimination of the display
so that the resulting function, if it compiles, is not only C callable, but also
has no direct access to Felix specific resources such as the thread frame or
garbage collector.

For the C function type, a trick is used. Since C has no concept of a tuple,
if the domain has a tuple type, the components are passed separately.

A C function can be used wherever a Felix function is required, this is done
by generating a Felix function wrapper around the C function. The wrapper
generation is automatic.

C functions and linear functions are subtypes of standard functions.
Linear functions promise to use their argument exactly once.

Felix functions are not permitted to have side effects. This is not
enforced, however the compiler performs optimisations assuming the rule
is followed.

A special kind of function called a generator, which has the same type
as a standard Felix function, is permitted to modify internal state.

The difference between a Felix function and generator is as follows:
when a Felix function closure is stored in a variable, an invocation of the function
calls a \verb$clone$ method to copy the object before calling the \verb$apply$ method
on that copy. This is to ensure recursion
works by ensuring the function get a separate data frame from any other
invocation.

If the function was a generator, the clone method is still called but simply
returns the this pointer of the object, ensuring that all invocations
of the \verb$apply$ method use the same data frame. In particular state
data is retained between applications, since the object is stored in a variable,
and even more particularly generators can save program locations, allowing them
to return a value and control in such a way that calling the \verb$apply$ method
again resumes execution where it last left off.

The representation of a Felix function is a C++ class derived from an abstract class
which represents the function type. The apply method is virtual. Closures of functions
are just pointers to an instance of the function. The C++ class constructor of a function
accepts the display values and saves them in the function object, this forming
an instance object. 

The run time function pointer can be safely upcast to the type of the function,
thus allowing a higher order function to accept and return function pointers.
Note that function objects are heap allocated by default although the optimiser
can stack allocate function objects if it is safe.


\section{Procedures}

A procedure is Felix is radically different to a function. Procedure are given the type

\begin{minted}{felix}
  D -> 0
\end{minted}

where the 0 suggests that procedures do not return a value. The representation of a procedure
consists of three methods.

\begin{enumerate}
\item constructor, creates closure
\item call method, binds arguments
\item resume method, steps procedure a bit
\end{enumerate}

The procedure constructor, like a function, accepts the display to form a closure object.
The call method, applied to the closure, binds the procedure argument into the data frame.
The result is a new kind of object called a continuation object.

Continuation objects all have the same type, \verb$con_t$ which is a base class for
the procedure type abstraction, which in turn is a base for the actual procedure.
The call method is a member of the type object, the resume method is a member
of the continuation object.

Continuation objects all contain a variable called the program counter which tells
where execution is up to within the procedure. Initially, it is set to the start
of the procedure. When the resume method is called, some work is done, and then
the procedure returns a pointer to a continuation object. It may be the same
object, however if the procedure is returning, it could be the callers continuation,
and if the procedure is calling another, it could be the called procedure's 
continuation object. A NULL is returned when the original procedure is finished.

Continuation objects are suspensions, the resume method is a function that
in effect accepts a suspension and returns another suspension. The role
of suspended computations will soon become evident!

\subsection{Routines}
For completeness, a routine is a procedure for which the current continuation
is not passed implicitly.  Felix currently uses procedure representation for
routines and passes the caller address anyhow.

\subsection{Coroutines}
A coroutine is a procedure which, directly or indirectly, does channel I/O.
It has the same representation as a procedure.

Technically, all procedures in Felix are coroutines. This includes the mainline!

\section{Procedure operation}
Procedures are run by repeatedly calling the resume method of a continuation
objectr until NULL is returned. In Felix, the loop is also sometimes enclosed
in a try/catch block to implement special semantics. The basic run loop is
extremely simple and lightning fast:

\begin{minted}{C++}
while (p) p = p -> resume();
\end{minted}

\subsection{Resume Method structure}
The resume method of a procedure for sequential flow is very simple:
\begin{minted}{C++}
  con_t *resume() {
     switch (PC) {
     case 0: ... PC = 1; return this;
     case 1: ... PC = 2; return this;
        ...
     case 42: ... return caller;
     }
   }
\end{minted}

In each case, at the end, the current continuation is simply the next case,
except at the end, when the current continuation of the caller is returned.

\subsection{Procedure Call}
A procedure call is implemented by constructing a new procedure object,
binding its arguments, and setting its caller to \verb$this$, then returning
that new procedure pointer. The call operation binding the parameters
also sets the PC to 0 to ensure it starts in the right place.

\subsection{Procedure Return}
This is implemented by simply returning the stored caller's this pointer.
When the driver loop calls resume() that procedure will continue where it left off.

\subsection{Other operations}
Procedures can also do various tricky things. For example the driver above
can be augmented:

\begin{minted}{C++}
again:
  try { while (p) p = p -> resume(); }
  catch (con_t q) { p = q; goto again; }
\end{minted}

This allows a procedure to throw a continuation object which then replaces
the existing continuation.

\subsection{Spaghetti Stack}
Continuations are linked in two ways to form a spaghetti stack: there is a list
of callers, terminated by NULL for the top level procedure call, and there
is notionally a list of ancestors, particularly the most recent activation records
of the ascestors, maintained through the parent pointer. Felix actually uses a display,
so that every procedure contains a pointer to every ancestor, including the base
ancestor, the thread frame. This reduces access time at the cost of additional storage
in nested frames, however unused pointers can be optimised away.

\subsection{Utility}
The technology described above has very little utility in itself. There is
no good reason for ordinary procedural code to return control to the driver,
only to be called again immediately. The utility will become evident in
the next section!

\section{Fibration}
Fibration is a method of interleaving control between fibres.

\subsection{fibre}
A fibre, or fthread (Felix thread) is an object containing a continuation pointer.
in Felix, fibre objects also contain a pointer to another fibre, possibly NULL,
which is used as decribed below.

\subsection{synchronous channel}
A synchronous channel, or schannel, is a set of fibres, possibly empty,
all of which are either waiting to read or waiting to write. It is represented
in Felix by linking fibres together through the special link, and storing
the head pointer in the schannel object, setting the low order bit of the
pointer to 1 if the fibres are waiting to write.

\subsection{scheduler}
A scheduler is an object with two variables, one which contains
the running fibre, and the other of which represents a set of fibres
called active fibres. These Felix representation uses the special link
in the fibre to represent the set of active fibres, and may be NULL.

The scheduler is a C++ procedure, which returns control when both there
are no active fibres left and the running fibre is exhausted.

\subsection{Channel I/O}
There are two operations for channel I/O, read an write.
They are identical except that data is transfered from the writer
to the reader. In Felix, the data is always a single machine word.
Read and write are said to be matching operations.

Read operates as follows. If you read a channel which is empty,
or contains only readers, then the fibre is added to the channel
reader list, and is removed as the running fibre.

If the channel contains a writer, one is selected and removed
from the list of waiting writers, data is transfered from the writer
to the reader, the reader is removed as the running fibre, and both
reader and writer are made active.

Write operation is dual, except the direction of data transfer
is still from the write to reader.

\subsection{Scheduler operation}
The scheduler runs the current fibre using the driver loop.
However in addition, it also checks a special code in the continuations
called a service request. This is a request to do a channel read, channel
write, suicide or spawn operation.

The read an write have already been described. Suicide simply removes the
currently running fibre. It is usually implemented by setting the fibre's
continuation pointer to NULL rather than using a service request.

Spawn takes a newly created fibre and makes it active, also making
the currently running fibre active but no longer running.

The scheduler operation is to start with some fibre as running,
and then, after a service request, the previously running fibre
is no longer running, so the scheduler picks another one to run,
removing it from the active set. If the active set is empty,
it returns control.

Although the formal semantics allow the scheduler to randomly pick
any active fibre to run, in Felix the operation is deterministic.
When a reader and write match up on an I/O request the reader is
always made active first, and the writer ends up on the top
of the active list so it will run next if not displaced.

Spawn always pushes the running fibre onto the active list and runs
the newly spawned fibre. This means that spawning and procedure
calling are identical if the spawned fibre makes no service
requests.


\clearpage
\phantomsection
\indexprologue{Listing Index}
\listoflistings
%
\clearpage
\phantomsection
\printindex[codeindex] 
%
\clearpage
\phantomsection
\printindex
%
\end{document}
